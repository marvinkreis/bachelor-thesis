% REMEMBER: Write the thesis from the view of the reader. How would I like to READ the thesis?
% WHY -> WHAT -> HOW structure

\chapter{Testing Approach}

% - IO
% - parallel scripts
% - overhead

\section{General Approach}

In this work, we propose a way to perform dynamic testing on Scratch programs.
The main goal of this approach is to be able to automatically assess student's solutions to Scratch assignments.
In order to do so, this approach makes use of a automation utility, which allows test code to interact with a running Scratch program.
% To enable dynamic testing for Scratch, we propose a black-bock approach with a testing utility, which allows test code to interact with a running Scratch program.
\parspace

Because Scratch's parallel scripts, as well as its lack of code separation, would make white-box testing difficult,
we instead chose to ignore the internals of the program and to go with a black-box approach, which only focuses on the program's input and output.
This raises the question of how to access Scratch's IO.
Since Scratch's input usually consists of mouse and keyboard input, and its output consists of visual animations and sound,
they are not easily accessible in a programmable way.
To overcome this challenge, we developed a automation utility called Whisker, which acts as a wrapper around Scratch.
It interacts with Scratch's virtual machine in order to automate its IO.
Whisker offers a programmable interface for Scratch, which makes automated testing for Scratch possible.
\mnote{TODO: reference figure in the text}
\parspace

Whisker is, like Scratch 3.0, implemented in JavaScript.
Hence, test code is also written in JavaScript.
Whisker can, in theory, be used with any JS testing framework,
but for compatibility reasons, we developed a rudimentary testing framework to go along with Whisker (more on this in section~\ref{TODO}).


% Therefore, we only concern ourselves with ...

% We are going to deal with this problem by creating a wrapper around Scratch,
% which can be used to simulate input and access information about the sprites which make up the output.
% Tests can then use methods, which the wrapper provides, instead of manually interacting with the Scratch program.

% Therefore, additional computations by the testing procedure must be fast enough to avoid interfering with the program under test.

\mnote{TODO: better captions for figures}
\begin{figure}[h]
    \centering

    \begin{subfigure}[b]{\textwidth}
        \centering
        \tikzset{>=latex,
                 put/.style={draw, text width=2.5cm, minimum height=1.7cm, minimum width=3.5cm, text centered, fill=red!20, rounded corners},
                  vm/.style={draw, minimum height=3.0cm, minimum width=6.0cm, fill=white, rounded corners},
                 gui/.style={draw, minimum height=4.2cm, minimum width=7.0cm, fill=blue!20, rounded corners},
            arrowtxt/.style={text width=3.3cm, midway}}

         \begin{tikzpicture}[scale=0.8, every node/.style={scale=0.8}]
            \begin{scope}[on background layer]
                \node[gui]     at (  5.9,  0.4) (gui)     {};
                \node[vm]      at (  5.9,  0.0) (vm)      {};
                \node[]        at ( -2.0,  0.4) (input)   {};
                \node[]        at ( 14.0,  0.4) (output)  {};
            \end{scope}

            \node[put]         at (  5.9, -0.4) (put)     {\textbf{Program under test}};
            \node[]            at (  5.9,  1.0) (vmtxt)   {\textbf{Scratch Virtual Machine}};
            \node[font=\large] at (  5.9,  2.0) (guitxt)  {\textbf{Scratch GUI}};

            \path [draw, ->] (input) -- node [arrowtxt, above] {\textbf{Input}} (gui);
            \path [draw, ->] (gui)   -- node [arrowtxt, above] {\textbf{Output}} (output);
            \path [draw, ->] (input) -- node [arrowtxt, below] {Key presses, mouse movement, mouse clicks, etc.} (gui);
            \path [draw, ->] (gui)   -- node [arrowtxt, below] {Visual animations, audio, etc.} (output);
        \end{tikzpicture}
        \caption{Input and output of the Scratch GUI}
        \label{fig:input_and_output_of_the_scratch_gui}
    \end{subfigure}

    \bigskip

    \begin{subfigure}[b]{\textwidth}
        \centering
        \tikzset{>=latex,
                 put/.style={draw, text width=2.5cm, minimum height=1.7cm, minimum width=3.5cm, text centered, fill=red!20, rounded corners},
                  vm/.style={draw, minimum height=3.0cm, minimum width=6.0cm, fill=white, rounded corners},
                util/.style={draw, minimum height=4.2cm, minimum width=7.0cm, fill=green!20, rounded corners},
            arrowtxt/.style={text width=3.3cm, midway}}

         \begin{tikzpicture}[scale=0.8, every node/.style={scale=0.8}]
            \begin{scope}[on background layer]
                \node[util]    at (  5.9,  0.4) (util)    {};
                \node[vm]      at (  5.9,  0.0) (vm)      {};
                \node[]        at ( -2.0,  0.4) (input)   {};
                \node[]        at ( 14.0,  0.4) (output)  {};
            \end{scope}

            \node[put]         at (  5.9, -0.4) (put)     {\textbf{Program under test}};
            \node[]            at (  5.9,  1.0) (vmtxt)   {\textbf{Scratch Virtual Machine}};
            \node[font=\large] at (  5.9,  2.0) (utiltxt) {\textbf{Whisker}};

            \path [draw, ->] (input) -- node [arrowtxt, above] {\textbf{Input}} (util);
            \path [draw, ->] (util)  -- node [arrowtxt, above] {\textbf{Output}} (output);
            \path [draw, ->] (input) -- node [arrowtxt, below] {Calls to input simulating interface methods} (util);
            \path [draw, ->] (util)  -- node [arrowtxt, below] {Interface to query information about sprites and variables} (output);
        \end{tikzpicture}
        \caption{Input and output of Whisker}
        \label{fig:input_and_output_of_whisker}
    \end{subfigure}

    \caption{Comparison of IO mechanisms}
    \label{fig:comparison_of_io_mechanisms}
\end{figure}

\section{Testing Procedure}

\mnote{TODO: better explanations and code examples}
Automating Scratch allows us to write tests for Scratch in a unit-test-like fashion.
Whisker can load and start the program before each test starts.
By doing this, every test starts with a fresh instance of the program in the exact same situation.
The test code can then interact with the program in order to produce a desired situation and check how to program behaves through assertions.
\parspace

mnote{TODO: properties depend on time $\rightarrow$ ''old'' values}
The following list will give an overview of Whisker's basic functions.
The Whisker instance will be denoted as $t$ in example code snippets.

\begin{itemize}
    \item \textbf{Simulate Input.}
        By simulating Scratch's main input methods, the test can control the tested program.
        The goal is to simulate a user interacting with the program.
        Therefore, this is the only way the test can manipulate the program.
        The possible input includes mouse movement, mouse button presses, keyboard key presses and entering answers to ask blocks.
        \begin{javascriptcode}
            t.addInput(1000, {
                device: 'keyboard',
                key: 'right arrow',
                isDown: true
            });
        \end{javascriptcode}
    \item \textbf{Access Information.}
        \mnote{Explain how in the implementation chapter (objects)}
        The testing utility can be used to access sprites and variables of the program.
        This makes it possible to gather information about anything, which is displayed on the stage.
        Analyzing Scratch's visual output would otherwise be very difficult.
        The provided sprite attributes include the sprite's position, rotation, size, current costume, speech bubble text, etc..
        The values of the program's variables can also be accessed.
        These variable values can usually be displayed to the user in Scratch's graphical output, and are commonly used in Scratch programs to convey information to the user.
        \begin{javascriptcode}
            const sprite = t.getSprite('Sprite1');
            const stage = t.getStage();
            const variable = stage.getVariable('my variable');
            console.log(sprite.x);
            console.log(variable.value);
        \end{javascriptcode}
    \item \textbf{Control the program execution.}
        The test is able to control when and for how long the program under test is run.
        In the beginning of the test, the program starts in a paused state with the green flag already pressed.
        The test can then run (resume) the program for a certain time, or until a condition is met.
        The green flag can also be pressed again in order to restart the program, which can, for example, be useful for testing programs, that use randomness.
        \begin{javascriptcode}
            await t.runForTime(1000);
            await t.runUntil(() => sprite.x > 100));
            t.greenFlag();
        \end{javascriptcode}
    \item \textbf{Register Callbacks.}
        The test can register callbacks, which get called every time Scratch renders a new picture.
        This allows the test to track the information, which the user would normally see, while the program is running.
        \begin{javascriptcode}
            const spritePositions = [];
            const callback = t.addCallback(() => spritePositions.push(sprite.pos));
            callback.disable();
            callback.enable();
        \end{javascriptcode}
    \item \textbf{Register constraints.}
        By registering constraints, the test can define conditions that must always hold true.
        Constraints are done through special callbacks, which perform assertions.
        For example, this can be used to define that a certain sprite must always be visible.
        \begin{javascriptcode}
            const constraint = t.addConstraint(() => {
                t.assert.ok(sprite.visible === true)
            });
            constraint.disable();
            constraint.enable();
        \end{javascriptcode}
\end{itemize}

\noindent Some things are, despite being possible in theory, explicitly \textbf{not} allowed in tests:

\begin{itemize}
    \item \textbf{Directly manipulate sprite attributes.}
        The test should only interact with the program like a user would.
        Directly manipulating sprites or variables could result in unexpected behaviour of the program.
        Therefore, it does not make sense to directly manipulate sprites for testing Scratch.
    \item \textbf{Execute single scripts or blocks directly}.
        The block box approach does not allow knowledge about the code of the program.
        Executing single scripts could also lead to unexpected behaviour from the program, because the scripts could depend on other scripts, which run parallelly.
\end{itemize}

\section{Advantages and Disadvantages}

\mnote{TODO: better explanations, better intro, small discussion}
This section will highlight some advantages and disadvantages of the presented testing approach.
\parspace

% - Scratch programs can be pretty inconsistent
%     - Some programs may only sometimes work and other times not
%     $\rightarrow$ They may or may not pass the test

\noindent Disadvantages:

\begin{itemize}
    \item Scratch programs have to be well specified, since testing relies on the program's specification.
        Therefore, if the specification is too vague, testing can become difficult.
        Tests for imprecise specifications potentially need to consider more possible cases of how the program could behave.
        Likewise, conflicting interpretations of the specification between the test and the program may result in false negative test outcomes.
    \item Since we only test the program as a whole, testing a single part of the program can be difficult.
        If, for example, some functionality of a program depends on another functionality being implemented correctly,
        but the latter does not work, we can not test the first functionality properly.
\end{itemize}

\noindent Advantages:

\begin{itemize}
    \item This approach allows to test programs with most of Scratch's functionality.
        Apart from sounds and extensions, anything, which Scratch has to offer, can be tested with this approach.
        In contrast, ITCH's previous testing approach limited Scratch programs to textual IO.
    \item Tests are easily understood, because they control the program like a normal person would.
        This is important, because students, whose programs are supposed to be tested later,
        could be allowed to run tests on their programs themselves during development.
        This way, students could easily receive valuable feedback about the correctness of their implementations.
        Therefore, it is beneficial to use tests, whose actions and purposes are easily understood by students.
\end{itemize}










\chapter{Using Constraints For Flexible Test Inputs}%
\label{cha:using_constraints_to_enable_flexible_test_inputs}

This section will describe why separating control of the program under test from the test code can be beneficial,
and how this can be achieved by using Whisker's  mechanism to define constraints.

\section{Input-Independent Tests}

Usually, tests will provide the program under test with inputs and check the resulting outputs.
However, in many cases, a different approach is possible as well.
Tests may use other sources of input and simply observe if the program's output is correct for the input provided by the source.
QuickCheck~\cite{quickcheck} by Claessen et al., for example, uses this this principle, to test the correctness of Haskell programs.
In order to do so, tests define conditions, which the program must comply with.
QuickCheck then automatically generates input for the program and checks if the defined conditions hold.
\parspace

Scratch programs can often be tested in a similar way.
But in order to be able to do this, tests have to be made independent of the simulated input on the program.
This will not just enable us to test with random input, but with other input sources as well.
For example, the program could be manually controlled by a person, or input could be recorded and played back.
Whisker also offers its own method of automated input generation by randomizing a set of inputs,
which are either provided by the test itself, or deduced by analyzing the program code (see section~\ref{TODO} for more information on this).
\parspace

Scratch tests can be made independent of inputs.
And Whisker provides the means to do this.
Using constraints allows us to define conditions, which the program must hold.
Constraints check the programs compliance to the conditions by continually performing assertions throughout the program execution.
Since this is done entirely in the background while the program under test is running, we can define some constraints and just let the program run for some time.
This way, it does not matter in what state the program is during its execution, or what inputs it is receiving.
If a condition does not hold, the respective constraint fails.

\section{Testing Procedure}

\begin{wrapfigure}{r}{0.35\textwidth + 5mm}
    \centering
    \vspace{-5mm}
    \tikzset{>=latex,
             box/.style={draw, text width=4.3cm, minimum height=0.7cm, text centered, rounded corners},
             num/.style={draw, circle, inner sep=0.6mm, text centered},
               h/.style={fill=blue!10}}

     \begin{tikzpicture}[scale=0.75, every node/.style={scale=0.75}]
        \node[box, h] at ( 0.2,  4.25) (tracking)    {Setup information tracking};
        \node[box, h] at ( 0.2,  3.0)  (constraints) {Register constraints};
        \node[box]    at ( 0.2,  2.0)  (inputs)      {(Simulate Inputs)};
        \node[box]    at ( 0.2,  1.0)  (run)         {Run the program};
        \node[box, h] at ( 0.2,  0.0)  (verify)      {Verify tested situation};

        \node[num] at (-2.6,  4.25) (one)   {1};
        \node[num] at (-2.6,  3.0)  (two)   {2};
        \node[num] at (-2.6,  2.0)  (three) {3};
        \node[num] at (-2.6,  1.0)  (four)  {4};
        \node[num] at (-2.6,  0.0)  (five)  {5};

        \draw[->]
               ( 0.2,  5.1)
            -- (tracking)
            -- (constraints)
            -- (inputs)
            -- (run)
            -- (verify)
            -- ( 0.2, -0.8);
    \end{tikzpicture}
    \vspace{-2mm}
    \caption{Input-Independent Test Procedure}
    \label{fig:input-independent-test-procedure}
\end{wrapfigure}
Figure~\ref{fig:input-independent-test-procedure} shows a testing procedure, which uses the aforementioned approach to test independently of the simulated input.
We will go through each step of the procedure with the aid of an example.
Consider program with a single sprite, which is supposed to move to the right precisely when the right arrow key is pressed.
We want to write a test to check if the sprite's movement works correctly.
Figure~\ref{fig:normal-input-independet-test-comparison} shows the resulting test code for the example and compares it to a similar test in a more common approach without defining constraints.

\begin{enumerate}
    \item \textbf{Setup information tracking.}
        The constraint, which we will have to define later, will depend on information, which is not always available.
        Because we need to determine the sprite's movement direction, we have to know the position of the sprite from the last rendered frame.
        In order to track this, we add a callback, which tracks the sprite's last position.
        (Note: Whisker makes the sprites' attributes from the last rendered frame available through \texttt{sprite.old}, but we are going to ignore this for the sake of the example)
        \begin{javascriptcode}
            let oldX;
            t.addCallback(() => {
                oldX = sprite.x;
            });
        \end{javascriptcode}
    \item \textbf{Register constraints.}
        Now, that we know the sprite's last position, we can determine if, and in which direction, it has moved since the last frame.
        We check its movement dependent on what key is currently pressed.
        \begin{javascriptcode}
            t.addConstraint(() => {
                if (t.isKeyDown("right arrow")) {
                    t.assert.ok(sprite.x > oldX);
                } else {
                    t.assert.ok(sprite.x === oldX);
                }
            });
        \end{javascriptcode}
    \item[3+4.] \textbf{Simulate Inputs, Run the program.}
        \setcounter{enumi}{4}
        Now we can register inputs if we want to, and then we can run the program.
        How we simulate inputs, or if we perform inputs manually, does not matter for the test, of course.
        \begin{javascriptcode}
            t.detectRandomInputs();
            await t.runForTime(5000);
        \end{javascriptcode}
    \item \textbf{Verify tested situation.}
        If our source of input does not guarantee, that the right arrow key gets pressed at all, we risk the chance of a false positive test result,
        because then, part of our constraint does not ever get checked.
        In this case, we also want set up tracking for the key press in the beginning,
        and then skip the test if the key does not get pressed at all in the end.
        \begin{javascriptcode}
            let rightPressed = false;
            const detectRight = t.addCallback(() => {
                if (t.isKeyDown("right arrow")) {
                    rightPressed = true;
                    detectRight.disable();
                }
            });

            ...

            t.assume.ok(rightPressed);
        \end{javascriptcode}
\end{enumerate}

\begin{figure}[h]
    \centering
    \begin{subfigure}[b]{.43\textwidth}
        \centering
        \begin{minted}[autogobble, breaklines, linenos, fontsize=\scriptsize, framesep=2mm, frame=lines]{javascript}
            const sp = t.getSprite('Sprite1');

            let oldX = sprite.x;

            await t.runForTime(1000);

            /* Sprite should not move when no key
               is pressed. */
            t.assert.ok(oldX === sprite.x);

            t.inputImmediate({
                device: 'keyboard',
                key: 'right arrow',
                isDown: true
            });

            await t.runForTime(1000);

            /* Sprite should move right when the
               right arrow key is pressed. */
            t.assert.ok(oldX < sprite.x);
        \end{minted}
        \caption{Normal test}
    \end{subfigure}
    \hspace{.08\textwidth}
    \begin{subfigure}[b]{.47\textwidth}
        \centering
        \begin{minted}[autogobble, breaklines, linenos, fontsize=\scriptsize, framesep=2mm, frame=lines]{javascript}
            const sprite = t.getSprite('Sprite1');

            /* Detect if the right key is pressed.
               Optional, if  the used input guaranties,
               that the right arrow key is pressed. */
            let rightPressed = false;
            const detectRight = t.addCallback(() => {
                if (t.isKeyDown("right arrow")) {
                    rightPressed = true;
                    detectRight.disable();
                }
            });

            /* (1) Track the x position of the sprite, so
               horizantal movement can be checked. */
            let oldX;
            t.addCallback(() => {
                oldX = sprite.x;
            });

            /* (2) Sprite should move right when the
               right arrow key is pressed. Sprite
               should not move when no key is pressed. */
            t.addConstraint(() => {
                if (t.isKeyDown("right arrow")) {
                    t.assert.ok(sprite.x > oldX);
                } else {
                    t.assert.ok(sprite.x === oldX);
                }
            });

            /* (3) Some code, which registers inputs.
               Or nothing if inputs are done manually.
               For example: */
            t.detectRandomInputs();

            /* (4) */
            await t.runForTime(5000);

            /* (5) Optional, if  the used input
               guaranties, that the right arrow key
               is pressed. */
            t.assume.ok(rightPressed);
        \end{minted}
        \caption{Input-independent test}
    \end{subfigure}
    \caption{Comparison of normal tests and an input-independent test using constraints}
    \label{fig:normal-input-independet-test-comparison}
\end{figure}

\section{Combining Tests}

Apart from being independent of their test input, a second advantage of this approach is that it allows tests to easily be combined.
By copying constraints and their necessary tracking from one test to another, the checks of one test can be combined with the other's checks.
Depending on the program, it may be possible to perform many tests with a single program execution.
In case tests are expected to fail, for example for automated assessment of student assignments,
Whisker also offers the option to simply disable failed constraints instead of failing the test.
This way, one can simply check which constraints failed at the end of the test, and generate some kind of test report about which of the checks failed.

\mnote{TODO: figure}

% \begin{figure}[h]
%     \centering
%     \begin{subfigure}[b]{.45\textwidth}
%         \centering
%         \tikzset{>=latex,
%                  box/.style={draw, text width=4.3cm, minimum height=0.7cm, text centered, rounded corners},
%                  num/.style={draw, circle, inner sep=0.6mm, text centered},
%                    h/.style={fill=blue!10}}
%
%         \begin{tikzpicture}
%             \node[box] at ( 0.2,  3.0) (run)        {Run the program};
%             \node[box] at ( 0.2,  2.0) (inputs)     {Simulate inputs};
%             \node[box] at ( 0.2,  1.0) (checks)     {Perform checks};
%
%             \node[num] at (-2.6,  3.0) (one)   {1};
%             \node[num] at (-2.6,  2.0) (two)   {2};
%             \node[num] at (-2.6,  1.0) (three) {3};
%
%             \draw[->]
%                    ( 0.2,  4.8)
%                 -- (run)
%                 -- (inputs)
%                 -- (checks)
%                 -- ( 0.2, -1.0);
%
%             \draw[shorten >= 2pt, rounded corners, dashed, ->]
%                    ( 0.2,  0.0)
%                 -- (-3.4,  0.0)
%                 -- (-3.4,  4.0)
%                 -- ( 0.2,  4.0);
%         \end{tikzpicture}
%
%         \caption{Normal Test Procedure}
%         \label{fig:normal_test_procedure}
%     \end{subfigure}
%     \begin{subfigure}[b]{.45\textwidth}
%         \centering
%         \tikzset{>=latex,
%                  box/.style={draw, text width=4.3cm, minimum height=0.7cm, text centered, rounded corners},
%                  num/.style={draw, circle, inner sep=0.6mm, text centered},
%                    h/.style={fill=blue!10}}
%
%         \begin{tikzpicture}
%             \node[box] at ( 0.2,  4.25) (tracking)    {Setup tracking of information};
%             \node[box] at ( 0.2,  3.0)  (constraints) {Register constraints};
%             \node[box] at ( 0.2,  2.0)  (run)         {Run the program};
%             \node[box] at ( 0.2,  1.0)  (inputs)      {(Simulate Inputs)};
%             \node[box] at ( 0.2,  0.0)  (filter)      {Filter constraints};
%
%             \node[num] at (-2.6,  4.25) (one)   {1};
%             \node[num] at (-2.6,  3.0)  (two)   {2};
%             \node[num] at (-2.6,  2.0)  (three) {3};
%             \node[num] at (-2.6,  1.0)  (four)  {4};
%             \node[num] at (-2.6,  0.0)  (five)  {5};
%
%             \draw[->]
%                    (tracking)
%                 -- (constraints)
%                 -- (run)
%                 -- (inputs)
%                 -- (filter)
%                 -- ( 0.2, -1.0);
%         \end{tikzpicture}
%
%         \caption{Constraint-only Test Procedure}
%         \label{fig:constraint_only_test_procedure}
%     \end{subfigure}
%     \caption{Comparison of the procedure of normal tests and constraint-only tests}
%     \label{fig:comparison_of_the_procedure_of_normal_tests_and_constraint_only_tests}
% \end{figure}
