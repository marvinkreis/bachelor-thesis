% REMEMBER: Write the thesis from the view of the reader. How would I like to READ the thesis?

\chapter{Testing Approach}

% - IO
% - parallel scripts
% - overhead

\section{General Approach}

In this work, we propose a way to perform dynamic testing on Scratch programs.
The main goal of this approach is to assess student-written solutions to Scratch assignments.
make use of a testing utility, which allows test code to interact with a running Scratch program.
% To enable dynamic testing for Scratch, we propose a black-bock approach with a testing utility, which allows test code to interact with a running Scratch program.

Because Scratch's parallel scripts and lack of code separation, would make white-box testing difficult,
we instead chose to ignore the internals and only focus on the input and output of the program.
Of course, this raises the question of how to access Scratch's IO.
Since Scratch's input usually consists of mouse and keyboard input, and its output consists of visual animations and sound,
they are not easily accessible in a programmable way.
To overcome this challenge, we developed a testing utility called Whisker, which acts as a wrapper around Scratch.
It interacts with Scratch's virtual machine in order to automate its IO.
Whisker offers a programmable interface for Scratch, which testing for Scratch possible.

Whisker is, like Scratch 3, implemented in JavaScript.
Hence, test code is also written in JavaScript.
Whisker can, in theory, be used with any JS testing framework,
but for compatibility reasons, we developed a rudimentary testing framework to go along with Whisker (more on this in section~\ref{TODO}).


% Therefore, we only concern ourselves with ...

% We are going to deal with this problem by creating a wrapper around Scratch,
% which can be used to simulate input and access information about the sprites which make up the output.
% Tests can then use methods, which the wrapper provides, instead of manually interacting with the Scratch program.

% Therefore, additional computations by the testing procedure must be fast enough to avoid interfering with the program under test.

\mnote{TODO: better captions}
\begin{figure}[h]
    \centering

    \begin{subfigure}[b]{\textwidth}
        \centering
        \tikzset{>=latex,
                 put/.style={draw, text width=2.5cm, minimum height=1.7cm, minimum width=3.5cm, text centered, fill=red!20, rounded corners},
                  vm/.style={draw, minimum height=3.0cm, minimum width=6.0cm, fill=white, rounded corners},
                 gui/.style={draw, minimum height=4.2cm, minimum width=7.0cm, fill=blue!20, rounded corners},
            arrowtxt/.style={text width=3.3cm, midway}}

         \begin{tikzpicture}[scale=0.8, every node/.style={scale=0.8}]
            \begin{scope}[on background layer]
                \node[gui]     at (  5.9,  0.4) (gui)     {};
                \node[vm]      at (  5.9,  0.0) (vm)      {};
                \node[]        at ( -2.0,  0.4) (input)   {};
                \node[]        at ( 14.0,  0.4) (output)  {};
            \end{scope}

            \node[put]         at (  5.9, -0.4) (put)     {\textbf{Program under test}};
            \node[]            at (  5.9,  1.0) (vmtxt)   {\textbf{Scratch Virtual Machine}};
            \node[font=\large] at (  5.9,  2.0) (guitxt)  {\textbf{Scratch GUI}};

            \path [draw, ->] (input) -- node [arrowtxt, above] {\textbf{Input}} (gui);
            \path [draw, ->] (gui)   -- node [arrowtxt, above] {\textbf{Output}} (output);
            \path [draw, ->] (input) -- node [arrowtxt, below] {Key presses, mouse movement, mouse clicks, etc.} (gui);
            \path [draw, ->] (gui)   -- node [arrowtxt, below] {Visual animations, audio, etc.} (output);
        \end{tikzpicture}
        \caption{Input and output of the Scratch GUI}
        \label{fig:input_and_output_of_the_scratch_gui}
    \end{subfigure}

    \bigskip

    \begin{subfigure}[b]{\textwidth}
        \centering
        \tikzset{>=latex,
                 put/.style={draw, text width=2.5cm, minimum height=1.7cm, minimum width=3.5cm, text centered, fill=red!20, rounded corners},
                  vm/.style={draw, minimum height=3.0cm, minimum width=6.0cm, fill=white, rounded corners},
                util/.style={draw, minimum height=4.2cm, minimum width=7.0cm, fill=green!20, rounded corners},
            arrowtxt/.style={text width=3.3cm, midway}}

         \begin{tikzpicture}[scale=0.8, every node/.style={scale=0.8}]
            \begin{scope}[on background layer]
                \node[util]    at (  5.9,  0.4) (util)    {};
                \node[vm]      at (  5.9,  0.0) (vm)      {};
                \node[]        at ( -2.0,  0.4) (input)   {};
                \node[]        at ( 14.0,  0.4) (output)  {};
            \end{scope}

            \node[put]         at (  5.9, -0.4) (put)     {\textbf{Program under test}};
            \node[]            at (  5.9,  1.0) (vmtxt)   {\textbf{Scratch Virtual Machine}};
            \node[font=\large] at (  5.9,  2.0) (utiltxt) {\textbf{Testing Utility}};

            \path [draw, ->] (input) -- node [arrowtxt, above] {\textbf{Input}} (util);
            \path [draw, ->] (util)  -- node [arrowtxt, above] {\textbf{Output}} (output);
            \path [draw, ->] (input) -- node [arrowtxt, below] {Interface to simulate input} (util);
            \path [draw, ->] (util)  -- node [arrowtxt, below] {Interface to query information about sprites and variables} (output);
        \end{tikzpicture}
        \caption{Input and output of the testing utility}
        \label{fig:input_and_output_of_the_testing utility}
    \end{subfigure}

    \caption{Comparison of IO mechanisms}
    \label{fig:comparison_of_io_mechanisms}
\end{figure}

\section{Testing Procedure}

Automating Scratch allows us to write tests for Scratch in a unit-test-like fashion.
Whisker can load and start the program before each test starts.
By doing this, we allow every test starts with a fresh instance of the program in the exact same situation.
The test code can then interact with the program in order to produce a desired situation and check how to program behaves through assertions.

The following list will give an overview of Whisker's basic functions.
The Whisker instance will be denoted as $t$ in example code snippets.

\begin{itemize}
    \item \textbf{Simulate Input.}
        By simulating Scratch's main input methods, the test can control the tested program.
        The goal is to simulate a user interacting with the program.
        Therefore, this is the only way the test can manipulate the program.
        The possible input includes mouse movement, mouse button presses, keyboard key presses and entering answers to ask blocks.
        \begin{javascriptcode}
            t.addInput(1000, {
                device: 'keyboard',
                key: 'right arrow',
                isDown: true
            });
        \end{javascriptcode}
    \item \textbf{Access Information.}
        \mnote{Explain how in the implementation chapter (objects)}
        The testing utility can be used to access sprites and variables of the program.
        This makes it possible to gather information about anything, which is displayed on the stage.
        Analyzing Scratch's visual output would otherwise be very difficult.
        The provided sprite attributes include the sprite's position, rotation, size, current costume, speech bubble text, etc..
        The values of the program's variables can also be accessed.
        These variable values can usually be displayed to the user in Scratch's graphical output, and are commonly used in Scratch programs to convey information to the user.
        \begin{javascriptcode}
            const sprite = t.getSprite('Sprite1');
            const stage = t.getStage();
            const variable = stage.getVariable('my variable');
            console.log(sprite.x);
            console.log(variable.value);
        \end{javascriptcode}
    \item \textbf{Control the program execution.}
        The test is able to control when and for how long the program under test is run.
        In the beginning of the test, the program starts in a paused state with the green flag already pressed.
        The test can then run (resume) the program for a certain time, or until a condition is met.
        The green flag can also be pressed again in order to restart the program, which can, for example, be useful for testing programs, that use randomness.
        \begin{javascriptcode}
            await t.runForTime(1000);
            await t.runUntil(() => sprite.x > 100));
        \end{javascriptcode}
    \item \textbf{Register Callbacks.}
        The test can register callbacks, which get called every time Scratch renders a new picture.
        This allows the test to track the information, which the user would normally see, while the program is running.
        \begin{javascriptcode}
            const spritePositions = [];
            t.addCallback(() => spritePositions.push(sprite.x));
        \end{javascriptcode}
    \item \textbf{Register constraints.}
        By registering constraints, the test can define conditions that must always hold true.
        Constraints are done through special callbacks, which perform assertions.
        For example, this can be used to define that a certain sprite must always be visible.
        \begin{javascriptcode}
            t.addConstraint(() => t.assert.ok(sprite.visible === true));
        \end{javascriptcode}
\end{itemize}

\noindent Some things are, despite being possible in theory, explicitly \textbf{not} allowed in tests:

\begin{itemize}
    \item \textbf{Directly manipulate sprite attributes.}
        The test should only interact with the program like a user would.
        Directly manipulating sprites or variables could result in unexpected behaviour of the program.
        Therefore, it does not make sense to directly manipulate sprites for testing Scratch.
    \item \textbf{Execute single scripts or blocks directly}.
        The block box approach does not allow knowledge about the code of the program.
        Executing single scripts could also lead to unexpected behaviour from the program, because the scripts could depend on other scripts, which run parallelly.
\end{itemize}

\section{Advantages and Disadvantages}

This section will highlight some disadvantages and advantages of the presented testing approach.

% - Scratch programs can be pretty inconsistent
%     - Some programs may only sometimes work and other times not
%     $\rightarrow$ They may or may not pass the test

\noindent Disadvantages:

\begin{itemize}
    \item Scratch programs have to be well specified, since testing relies on the program's specification.
        Therefore, if the specification is too vague, testing can become difficult.
        Tests for imprecise specifications potentially need to consider more possible cases of how the program could behave.
        Likewise, conflicting interpretations of the specification between the test and the program may result in false negative test outcomes.
    \item Since we only test the program as a whole, testing a single part of the program can be difficult.
        If, for example, some functionality of a program depends on another functionality being implemented correctly,
        but the latter does not work, we can not test the first functionality properly.
\end{itemize}

\noindent Advantages:

\begin{itemize}
    \item This approach allows to test programs with most of Scratch's functionality.
        Apart from sounds and extensions, anything, which Scratch has to offer, can be tested with this approach.
        In contrast, ITCH's previous testing approach limited Scratch programs to textual IO.
    \item Tests are easily understood, because they control the program like a normal person would.
        This is important, because students, whose programs are supposed to be tested later,
        could be allowed to run tests on their programs themselves during development.
        This way, students could easily receive valuable feedback about the correctness of their implementations.
        Therefore, it is beneficial to have tests, whose actions and purposes are easily understood by students.
\end{itemize}

\section{Constraint-only Tests}%
\label{sec:constraint_only_tests}

- TODO: when constraints are checked can't be clear here, a different implementation could allow constraints to be checked e.g. when a value is changed.

- Normally, tests would deliberately simulate input on the program, then perform some assertions
- Constraints open up a new approach to testing Scratch programs by only defining constraints instead of doing normal assertions
- In the end of the test, it has to be checked if the desired situation for the constraint occurred during the program execution
    - E.g. a constraint that describes the movement speed of a sprite will always hold if the sprite does not move at all
    - $\rightarrow$ The constraint need to be filtered
- This makes it possible to separate the checking of properties from the execution of the program
    - Checks are only done through constraints, which run in the background
    $\rightarrow$ This is independent from the program execution
    $\rightarrow$ The program can be controlled by arbitrary input, as long as the desired situation for the constraint(s) comes about
        - Deliberately simulated input
        - Manual user input
        - Random input ($\rightarrow$ well-suited for random input, because the test is independent from the source of input)
          Similar approaches have been used in other testing applications, e.g. QuickCheck \cite{quickcheck}

- Normal tests vs. constraint-only tests
    - Normal tests can be more granular $\rightarrow$ better for grading
    - Normal tests allow to write very short tests for things that can be checked fast
        - More difficult if everything is tested in a single constraint-only test
        $\rightarrow$ Better for continuous development, because it's easier to quickly execute just one test
    - Constraint-only test require more processing, constraints have to be checked between every step
    - Constraints can't fully replace normal assertions: some properties are better checked with normal assertions (e.g. a property only has to hold for one point in time)

% \begin{figure}[h]
%     \centering
%     \begin{subfigure}[b]{.45\textwidth}
%         \centering
%         \tikzset{>=latex,
%                  box/.style={draw, text width=4.3cm, minimum height=0.7cm, text centered, rounded corners},
%                  num/.style={draw, circle, inner sep=0.6mm, text centered},
%                    h/.style={fill=blue!10}}
%
%         \begin{tikzpicture}
%             \node[box] at ( 0.2,  3.0) (run)        {Run the program};
%             \node[box] at ( 0.2,  2.0) (inputs)     {Simulate inputs};
%             \node[box] at ( 0.2,  1.0) (checks)     {Perform checks};
%
%             \node[num] at (-2.6,  3.0) (one)   {1};
%             \node[num] at (-2.6,  2.0) (two)   {2};
%             \node[num] at (-2.6,  1.0) (three) {3};
%
%             \draw[->]
%                    ( 0.2,  4.8)
%                 -- (run)
%                 -- (inputs)
%                 -- (checks)
%                 -- ( 0.2, -1.0);
%
%             \draw[shorten >= 2pt, rounded corners, dashed, ->]
%                    ( 0.2,  0.0)
%                 -- (-3.4,  0.0)
%                 -- (-3.4,  4.0)
%                 -- ( 0.2,  4.0);
%         \end{tikzpicture}
%
%         \caption{Normal Test Procedure}
%         \label{fig:normal_test_procedure}
%     \end{subfigure}
%     \begin{subfigure}[b]{.45\textwidth}
%         \centering
%         \tikzset{>=latex,
%                  box/.style={draw, text width=4.3cm, minimum height=0.7cm, text centered, rounded corners},
%                  num/.style={draw, circle, inner sep=0.6mm, text centered},
%                    h/.style={fill=blue!10}}
%
%         \begin{tikzpicture}
%             \node[box] at ( 0.2,  4.25) (tracking)    {Setup tracking of information};
%             \node[box] at ( 0.2,  3.0)  (constraints) {Register constraints};
%             \node[box] at ( 0.2,  2.0)  (run)         {Run the program};
%             \node[box] at ( 0.2,  1.0)  (inputs)      {(Simulate Inputs)};
%             \node[box] at ( 0.2,  0.0)  (filter)      {Filter constraints};
%
%             \node[num] at (-2.6,  4.25) (one)   {1};
%             \node[num] at (-2.6,  3.0)  (two)   {2};
%             \node[num] at (-2.6,  2.0)  (three) {3};
%             \node[num] at (-2.6,  1.0)  (four)  {4};
%             \node[num] at (-2.6,  0.0)  (five)  {5};
%
%             \draw[->]
%                    (tracking)
%                 -- (constraints)
%                 -- (run)
%                 -- (inputs)
%                 -- (filter)
%                 -- ( 0.2, -1.0);
%         \end{tikzpicture}
%
%         \caption{Constraint-only Test Procedure}
%         \label{fig:constraint_only_test_procedure}
%     \end{subfigure}
%     \caption{Comparison of the procedure of normal tests and constraint-only tests}
%     \label{fig:comparison_of_the_procedure_of_normal_tests_and_constraint_only_tests}
% \end{figure}
